
CrossPts = [
[	-2,	+0,	+0,	+0],
[	+0,	-2,	+0,	+0],
[	+0,	+0,	-2,	+0],
[	+0,	+0,	+0,	-2],
[	+2,	+0,	+0,	+0],
[	+0,	+2,	+0,	+0],
[	+0,	+0,	+2,	+0],
[	+0,	+0,	+0,	+2],
[	-1,	-1,	-1,	-1],
[	-1,	-1,	-1,	+1],
[	-1,	-1,	+1,	-1],
[	-1,	-1,	+1,	+1],
[	-1,	+1,	-1,	-1],
[	-1,	+1,	-1,	+1],
[	-1,	+1,	+1,	-1],
[	-1,	+1,	+1,	+1],
[	+1,	-1,	-1,	-1],
[	+1,	-1,	-1,	+1],
[	+1,	-1,	+1,	-1],
[	+1,	-1,	+1,	+1],
[	+1,	+1,	-1,	-1],
[	+1,	+1,	-1,	+1],
[	+1,	+1,	+1,	-1],
[	+1,	+1,	+1,	+1]];
CrossLin = [
[0,		8],
[8,		9],
[9,		0],
[8,		10],
[10,	0],
[1,		8],
[9,		1],
[10,	1],
[10,	11],
[11,	0],
[9,		11],
[11,	1],
[8,		12],
[12,	0],
[2,		8],
[9,		2],
[12,	2],
[12,	13],
[13,	0],
[9,		13],
[13,	2],
[3,		8],
[10,	3],
[12,	3],
[12,	14],
[14,	0],
[10,	14],
[14,	3],
[8,		16],
[16,	1],
[16,	2],
[9,		17],
[17,	1],
[17,	2],
[16,	17],
[16,	3],
[10,	18],
[18,	1],
[16,	18],
[18,	3],
[16,	20],
[20,	2],
[20,	3],
[12,	20],
[14,	15],
[15,	0],
[13,	15],
[5,		12],
[13,	5],
[14,	5],
[15,	5],
[11,	15],
[6,		10],
[11,	6],
[14,	6],
[15,	6],
[7,		9],
[11,	7],
[13,	7],
[15,	7],
[11,	19],
[19,	1],
[18,	19],
[18,	6],
[19,	6],
[17,	7],
[17,	19],
[19,	7],
[17,	21],
[21,	2],
[13,	21],
[21,	7],
[4,		16],
[17,	4],
[18,	4],
[19,	4],
[20,	4],
[20,	21],
[21,	4],
[20,	22],
[22,	3],
[18,	22],
[22,	4],
[20,	5],
[21,	5],
[14,	22],
[22,	5],
[22,	6],
[22,	23],
[23,	4],
[21,	23],
[23,	5],
[19,	23],
[23,	6],
[23,	7],
[15,	23]];
CrossFacs = [
[	0,	8,	9],
[	0,	8,	10],
[	1,	8,	9],
[	1,	8,	10],
[	0,	10,	11],
[	0,	9,	11],
[	1,	10,	11],
[	1,	9,	11],
[	0,	8,	12],
[	2,	8,	9],
[	2,	8,	12],
[	0,	12,	13],
[	0,	9,	13],
[	2,	9,	13],
[	2,	12,	13],
[	3,	8,	10],
[	3,	8,	12],
[	0,	12,	14],
[	0,	10,	14],
[	3,	12,	14],
[	3,	10,	14],
[	1,	8,	16],
[	2,	8,	16],
[	1,	9,	17],
[	2,	9,	17],
[	1,	16,	17],
[	2,	16,	17],
[	3,	8,	16],
[	1,	10,	18],
[	1,	16,	18],
[	3,	16,	18],
[	3,	10,	18],
[	2,	16,	20],
[	3,	16,	20],
[	2,	12,	20],
[	3,	12,	20],
[	0,	14,	15],
[	0,	13,	15],
[	5,	12,	13],
[	5,	12,	14],
[	5,	14,	15],
[	5,	13,	15],
[	0,	11,	15],
[	6,	10,	11],
[	6,	10,	14],
[	6,	14,	15],
[	6,	11,	15],
[	7,	9,	11],
[	7,	9,	13],
[	7,	13,	15],
[	7,	11,	15],
[	1,	11,	19],
[	1,	18,	19],
[	6,	10,	18],
[	6,	18,	19],
[	6,	11,	19],
[	7,	9,	17],
[	1,	17,	19],
[	7,	17,	19],
[	7,	11,	19],
[	2,	17,	21],
[	2,	13,	21],
[	7,	17,	21],
[	7,	13,	21],
[	4,	16,	17],
[	4,	16,	18],
[	4,	18,	19],
[	4,	17,	19],
[	4,	16,	20],
[	2,	20,	21],
[	4,	20,	21],
[	4,	17,	21],
[	3,	20,	22],
[	3,	18,	22],
[	4,	20,	22],
[	4,	18,	22],
[	5,	12,	20],
[	5,	20,	21],
[	5,	13,	21],
[	3,	14,	22],
[	5,	20,	22],
[	5,	14,	22],
[	6,	18,	22],
[	6,	14,	22],
[	4,	22,	23],
[	4,	21,	23],
[	5,	22,	23],
[	5,	21,	23],
[	4,	19,	23],
[	6,	22,	23],
[	6,	19,	23],
[	7,	21,	23],
[	7,	19,	23],
[	5,	15,	23],
[	6,	15,	23],
[	7,	15,	23]];

CrossSolids = [
[	0,	1,	2,	3,	4,	5,	6,	7	],
[	0,	8,	9,	10,	11,	12,	13,	14	],
[	10,	16,	22,	27,	32,	33,	34,	35	],
[	11,	17,	36,	37,	38,	39,	40,	41	],
[	13,	24,	48,	56,	60,	61,	62,	63	],
[	14,	34,	38,	61,	69,	76,	77,	78	],
[	1,	8,	15,	16,	17,	18,	19,	20	],
[	19,	35,	39,	72,	76,	79,	80,	81	],
[	20,	31,	44,	53,	73,	79,	82,	83	],
[	25,	29,	52,	57,	64,	65,	66,	67	],
[	26,	32,	60,	64,	68,	69,	70,	71	],
[	2,	9,	21,	22,	23,	24,	25,	26	],
[	30,	33,	65,	68,	72,	73,	74,	75	],
[	3,	15,	21,	27,	28,	29,	30,	31	],
[	40,	45,	81,	83,	86,	89,	93,	94	],
[	41,	49,	63,	78,	87,	91,	93,	95	],
[	41,	49,	63,	78,	87,	91,	93,	95	],
[	4,	18,	36,	42,	43,	44,	45,	46	],
[	5,	12,	37,	42,	47,	48,	49,	50	],
[	54,	66,	75,	82,	84,	88,	89,	90	],
[	58,	62,	67,	71,	85,	88,	91,	92	],
[	6,	28,	43,	51,	52,	53,	54,	55	],
[	70,	74,	77,	80,	84,	85,	86,	87	],
[	7,	23,	47,	51,	56,	57,	58,	59	]
]

for (var i = 0;  i < CrossFacs.length; i++)
{
	for (var j = 0; j < CrossLin.length; j++)
	{
		if ((CrossFacs[i][0] == CrossLin[j][0]) && (CrossFacs[i][1] == CrossLin[j][1]))	{CrossFacs[i][3] = j;	CrossLin[j].push(i);}
		if ((CrossFacs[i][0] == CrossLin[j][1]) && (CrossFacs[i][1] == CrossLin[j][0]))	{CrossFacs[i][3] = j;	CrossLin[j].push(i);}
		if ((CrossFacs[i][1] == CrossLin[j][0]) && (CrossFacs[i][2] == CrossLin[j][1]))	{CrossFacs[i][4] = j;	CrossLin[j].push(i);}
		if ((CrossFacs[i][1] == CrossLin[j][1]) && (CrossFacs[i][2] == CrossLin[j][0]))	{CrossFacs[i][4] = j;	CrossLin[j].push(i);}
		if ((CrossFacs[i][2] == CrossLin[j][0]) && (CrossFacs[i][0] == CrossLin[j][1]))	{CrossFacs[i][5] = j;	CrossLin[j].push(i);}
		if ((CrossFacs[i][2] == CrossLin[j][1]) && (CrossFacs[i][0] == CrossLin[j][0]))	{CrossFacs[i][5] = j;	CrossLin[j].push(i);}
	}
}
console.log(CrossFacs);
console.log(CrossLin);
console.log("got all lines for faces");




var offs1 = 4
for (var i = 0; i < CrossPts.length; i++)
{
	CrossPts[i][3] += offs1;
}
//offs1 = 0.2
// console.log(CrossPts);


cross3 = [];
cross33 = [];
for (var i = 0; i < CrossPts.length; i++)
{

	cross33[i] = new THREE.Vector3(	CrossPts[i][0]/CrossPts[i][3],
	 								CrossPts[i][1]/CrossPts[i][3],
	 								CrossPts[i][2]/CrossPts[i][3]);	
	// cross3[i] = [	CrossPts[i][0]/CrossPts[i][3],
	// 				CrossPts[i][1]/CrossPts[i][3],
	// 				CrossPts[i][2]/CrossPts[i][3]];
}


//console.log(cross3);
// cross3 = math.transpose(cross3);





f2 = Math.PI * 40/180

R1 = [[1,0,0], [0, Math.cos(f2), Math.sin(f2)],[0, -Math.sin(f2), Math.cos(f2)]]


R2 = [[Math.cos(f2), 0, Math.sin(f2)],[0,1,0], [-Math.sin(f2), 0, Math.cos(f2)]]





//cross3 = math.multiply(R1, cross3);

//cross3 = math.transpose(cross3);

var newSolidsOffsets = [];
for (var s = 0; s < CrossSolids.length; s++)
{
	var center = new THREE.Vector3(0,0,0);
	for (var f = 0; f < 8; f++)
	for (var p = 0; p < 3; p++)
	{
		solid = CrossSolids[s];
		face = solid[f];
		facedata = CrossFacs[face];
		point = facedata[p];
		pointdata = cross33[point];
		center.add(pointdata);
		// center = math.add(center, pointdata);
	}
	newSolidsOffsets[s] = center;
	console.log(center);
}



offs2 = 400;
for (var i = 0; i < cross3.length; i++)
{
	cross3[i][2] += offs2;
}

console.log("cross3 = ");
console.log(cross3);

// cross2 = math.multiply(300 * offs1 * offs2, cross2);
// cross2 = math.add(900, cross2);

// lni = lnc;
SolidOffsets = [];
for (var s = 0; s < CrossSolids.length; s+=3)
{
    var Poly = new THREE.Geometry();

    var polyLine = new THREE.LineSegments(Poly, shad);
    // polyLine.position.set(-1,0,0);
    sce.add(polyLine);

	for (var f = 0; f < 8; f++)
	{
		if (true)
		for (var l = 0; l < 3; l++)
		{

			solid = CrossSolids[s];
			face = solid[f];
			facedata = CrossFacs[face];
	
			Poly.vertices.push(facedata[0]);
			Poly.vertices.push(facedata[1]);
			Poly.vertices.push(facedata[1]);
			Poly.vertices.push(facedata[2]);
			Poly.vertices.push(facedata[2]);
			Poly.vertices.push(facedata[0]);
			// var v2 = new THREE.Vector3(1,0-s,0);  Poly.vertices.push(v2);
			// var v3 = new THREE.Vector3(0,1-s,0);  Poly.vertices.push(v3);Poly.vertices.push(v1);Poly.vertices.push(v3);Poly.vertices.push(v2);

			// console.log(lni[i][0])
			// console.log(cube[lni[i][0]]);
			// console.log(cube[lni[i][1]]);
			// line = facedata[3+l];
			// linedata = CrossLin[line];
			// face = solid[f];
			// line = face[]
			// ctx.lineTo(	cross3[ CrossLin[i][0] ][0],
			// 			cross3[ CrossLin[i][0] ][1]);
			// ctx.lineTo(	cross3[ CrossLin[i][1] ][0],
			// 			cross3[ CrossLin[i][1] ][1]);
			
			// ctx.beginPath();
			// ctx.lineTo(	cross2[ linedata[0] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ linedata[0] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.lineTo(	cross2[ linedata[1] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ linedata[1] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.stroke();	
		}
		else
		{

		// console.log(lni[i][0])
		// console.log(cube[lni[i][0]]);
		// console.log(cube[lni[i][1]]);
		solid = CrossSolids[s];
		face = solid[f];
		facedata = CrossFacs[face];
		
			// ctx.beginPath();
			// ctx.lineTo(	cross2[ facedata[0] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ facedata[0] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.lineTo(	cross2[ facedata[1] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ facedata[1] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.lineTo(	cross2[ facedata[2] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ facedata[2] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.lineTo(	cross2[ facedata[0] ][0] + newSolidsOffsets[s][0] * 4*offs1,
			// 			cross2[ facedata[0] ][1] + newSolidsOffsets[s][1] * 4*offs1);
			// ctx.stroke();	



			var a = facedata[0];
			var b = facedata[1];
			var c = facedata[2];
			var pts = [];
			pts.push([cross2[a][0] + newSolidsOffsets[s][0] * 6*offs1, cross2[a][1] + newSolidsOffsets[s][1] * 6*offs1]);  
			pts.push([cross2[b][0] + newSolidsOffsets[s][0] * 6*offs1, cross2[b][1] + newSolidsOffsets[s][1] * 6*offs1]);  
			pts.push([cross2[c][0] + newSolidsOffsets[s][0] * 6*offs1, cross2[c][1] + newSolidsOffsets[s][1] * 6*offs1]);  

			subdiv(pts, 4);
			if (false)
			for (var i = 0; i < 4; i++)
			{
				var a = facedata[0];
				var b = facedata[1];
				var c = facedata[2];
				var d = facedata[1];
				var e = facedata[2];
				var g = facedata[0];

				if (i == 0)	{ d = e = g = a;	}
				if (i == 1)	{ d = e = g = b;	}
				if (i == 2)	{ d = e = g = c;	}

			ctx.beginPath();
			ctx.lineTo(	cross2[ a ][0]/2 + cross2[ d ][0]/2 + newSolidsOffsets[s][0] * 4*offs1,
						cross2[ a ][1]/2 + cross2[ d ][1]/2 + newSolidsOffsets[s][1] * 4*offs1);
			ctx.lineTo(	cross2[ b ][0]/2 + cross2[ e ][0]/2 + newSolidsOffsets[s][0] * 4*offs1,
						cross2[ b ][1]/2 + cross2[ e ][1]/2 + newSolidsOffsets[s][1] * 4*offs1);
			ctx.lineTo(	cross2[ c ][0]/2 + cross2[ g ][0]/2 + newSolidsOffsets[s][0] * 4*offs1,
						cross2[ c ][1]/2 + cross2[ g ][1]/2 + newSolidsOffsets[s][1] * 4*offs1);
			ctx.lineTo(	cross2[ a ][0]/2 + cross2[ d ][0]/2 + newSolidsOffsets[s][0] * 4*offs1,
						cross2[ a ][1]/2 + cross2[ d ][1]/2 + newSolidsOffsets[s][1] * 4*offs1);
			ctx.stroke();	
			}
		}
	}

}
function subdiv(vars, depth)
{		
	for (var i = 0; i < 4; i++)
	{
		var a = vars[0];
		var b = vars[1];
		var c = vars[2];
		var d = vars[1];
		var e = vars[2];
		var g = vars[0];

		if (i == 0)	{ d = e = g = a;	}
		if (i == 1)	{ d = e = g = b;	}
		if (i == 2)	{ d = e = g = c;	}

		if (depth == 0)
		{
			ctx.beginPath();
			ctx.lineTo(	a[0] + Math.random(),
						a[1] + Math.random());
			ctx.lineTo(	b[0] + Math.random(),
						b[1] + Math.random());
			ctx.lineTo(	c[0] + Math.random(),
						c[1] + Math.random());
			ctx.lineTo(	a[0] + Math.random(),
						a[1] + Math.random());
			ctx.stroke();	

			// ctx.beginPath();
			// ctx.lineTo(	a[0]/2 + d[0]/2 + vars[3][0] * 4*offs1,
			// 			a[1]/2 + d[1]/2 + vars[3][1] * 4*offs1);
			// ctx.lineTo(	b[0]/2 + e[0]/2 + vars[3][0] * 4*offs1,
			// 			b[1]/2 + e[1]/2 + vars[3][1] * 4*offs1);
			// ctx.lineTo(	c[0]/2 + g[0]/2 + vars[3][0] * 4*offs1,
			// 			c[1]/2 + g[1]/2 + vars[3][1] * 4*offs1);
			// ctx.lineTo(	a[0]/2 + d[0]/2 + vars[3][0] * 4*offs1,
			// 			a[1]/2 + d[1]/2 + vars[3][1] * 4*offs1);
			// ctx.stroke();	
				
		}
		else
		{
			var pts = [];
			pts.push([a[0]/2 + d[0]/2, a[1]/2 + d[1]/2]);
			pts.push([b[0]/2 + e[0]/2, b[1]/2 + e[1]/2]);
			pts.push([c[0]/2 + g[0]/2, c[1]/2 + g[1]/2]);
			subdiv(pts, depth-1);
		}	
	}
}